

#include <fix_ide.h>


igl_binding("test_binding")
igl_input("b", "matches(a)")
igl_input("a", "type_f32", "type_f64")
igl_output("out3", "matches(c)")
igl_input("c", "type_i32", "type_i64")
igl_input("d", "matches(c)")
igl_input("e", "matches(d)")

igl_begin_code()

// TODO: Macros for these typedefs
typedef IGL_PY_TYPE_a::Scalar Scalar_a;
typedef Eigen::Matrix<
    Scalar_a,
    Eigen::Dynamic,
    Eigen::Dynamic,
    IGL_PY_TYPE_a::Order> Type_a;
Scalar_a* a_data = (Scalar_a*) a.data();
int a_shape_0 = a.shape()[0];
int a_shape_1 = a.shape()[1];
Eigen::Map<Type_a, Eigen::Aligned> A(a_data, a_shape_0, a_shape_1);

typedef IGL_PY_TYPE_b::Scalar Scalar_b;
typedef Eigen::Matrix<
    Scalar_b,
    Eigen::Dynamic,
    Eigen::Dynamic,
    IGL_PY_TYPE_b::Order> Type_b;
Scalar_b* b_data = (Scalar_b*) b.data();
int b_shape_0 = b.shape()[0];
int b_shape_1 = b.shape()[1];
Eigen::Map<Type_b, Eigen::Aligned> B(b_data, b_shape_0, b_shape_1);

Type_a C = A + B;

// TODO: Check that this is doing a move and not a copy
return py::detail::eigen_encapsulate<py::detail::EigenProps<Type_a>>(new Type_a(std::move(C)));
igl_end_code()


