

#include <fix_ide.h>


igl_binding("test_binding")
igl_input("b", "matches(a)")
igl_input("a", "type_f32")
igl_output("out3", "matches(c)")
igl_input("c", "type_i32", "type_i64")
igl_input("d", "matches(c)")
igl_input("e", "matches(d)")

igl_begin_code()

// TODO: Macros for these typedefs
typedef IGL_PY_TYPE_a::Scalar Scalar_a;
typedef Eigen::Matrix<
    Scalar_a,
    Eigen::Dynamic,
    Eigen::Dynamic,
    IGL_PY_TYPE_a::Order> Type_a;
Scalar_a* a_data = (Scalar_a*) a.data();
int a_shape_0 = a.shape()[0];
int a_shape_1 = a.shape()[1];
Eigen::Map<Type_a, Eigen::Aligned> A(a_data, a_shape_0, a_shape_1);

typedef IGL_PY_TYPE_b::Scalar Scalar_b;
typedef Eigen::Matrix<
    Scalar_b,
    Eigen::Dynamic,
    Eigen::Dynamic,
    IGL_PY_TYPE_b::Order> Type_b;
Scalar_b* b_data = (Scalar_b*) b.data();
int b_shape_0 = b.shape()[0];
int b_shape_1 = b.shape()[1];
Eigen::Map<Type_b, Eigen::Aligned> B(b_data, b_shape_0, b_shape_1);

Type_a C = A + B; // TODO: Move constructor back from numpy

cout << C << endl;

//return 1.0;
/*
template <typename props, typename Type, typename = enable_if_t<is_eigen_dense_plain<Type>::value>>
handle eigen_encapsulate(Type *src) {
    capsule base(src, [](void *o) { delete static_cast<Type *>(o); });
    return eigen_ref_array<props>(*src, base);
}
*/
return py::detail::eigen_encapsulate<py::detail::EigenProps<Type_a>>(new Type_a(std::move(C)));
igl_end_code()


